/* @flow */

// Package reference provides a general type to represent any way of referencing images within the registry.
// Its main purpose is to abstract tags and digests (content-addressable hash).
//
// Grammar
//
// 	reference                       := name [ ":" tag ] [ "@" digest ]
//	name                            := [domain '/'] path-component ['/' path-component]*
//	domain                          := domain-component ['.' domain-component]* [':' port-number]
//	domain-component                := /([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])/
//	port-number                     := /[0-9]+/
//	path-component                  := alpha-numeric [separator alpha-numeric]*
// 	alpha-numeric                   := /[a-z0-9]+/
//	separator                       := /[_.]|__|[-]*/
//
//	tag                             := /[\w][\w.-]{0,127}/
//
//	digest                          := digest-algorithm ":" digest-hex
//	digest-algorithm                := digest-algorithm-component [ digest-algorithm-separator digest-algorithm-component ]*
//	digest-algorithm-separator      := /[+.-_]/
//	digest-algorithm-component      := /[A-Za-z][A-Za-z0-9]*/
//	digest-hex                      := /[0-9a-fA-F]{32,}/ ; At least 128 bit digest value
//
//	identifier                      := /[a-f0-9]{64}/
//	short-identifier                := /[a-f0-9]{6,64}/
const {CONTAINER_NAME_RE} = require('./parseContainerName');
const {isNil} = require('../../utils/types');

interface TextMarshaler {
  MarshalText: (text: Buffer, err: Error)=>void;
}

interface TextUnmarshaler {
  UnmarshalText: (text: Buffer)=>? Error;
}

type Algorithm = string;
type Digest = string;

// type Digest = string;

interface Hash {
  // Write (via the embedded io.Writer interface) adds more data to the running hash.
  // It never returns an error.
  // io.Writer,

  // Sum appends the current hash to b and returns the resulting slice.
  // It does not change the underlying hash state.
  Sum: (b: Array<number>)=> Array<number>,

  // Reset resets the Hash to its initial state.
  Reset: ()=>void,

  // Size returns the number of bytes Sum will return.
  Size: ()=>number,

  // BlockSize returns the hash's underlying block size.
  // The Write method must be able to accept any amount
  // of data, but it may operate more efficiently if all writes
  // are a multiple of the block size.
  BlockSize: ()=> number,
}


// Digester calculates the digest of written data. Writes should go directly
// to the return value of Hash, while calling Digest will return the current
// value of the digest.
interface Digester {
  Hash: Hash, // provides direct access to underlying hash instance.
  Digest: Digest
}

// digester provides a simple digester definition that embeds a hasher.
type digester = {
  alg: Algorithm,
  hash: Hash
}

const SHA256: Algorithm = 'sha256'; // sha256 with hex encoding (lower case only)
const SHA384: Algorithm = 'sha384'; // sha384 with hex encoding (lower case only)
const SHA512: Algorithm = 'sha512'; // sha512 with hex encoding (lower case only)

// Canonical is the primary digest algorithm used with the distribution
// project. Other digests may be used but this one is the primary storage
// digest.
const Canonical: Algorithm = SHA256;

/**
 * NameTotalLengthMax is the maximum total number of characters in a repository name.
 * @constant NameTotalLengthMax {number}
 * @type {number}
 */
const NameTotalLengthMax = 255;

// ErrReferenceInvalidFormat represents an error while trying to parse a string as a reference.
const ErrReferenceInvalidFormat = new Error('invalid reference format');

// ErrTagInvalidFormat represents an error while trying to parse a string as a tag.
const ErrTagInvalidFormat = new Error('invalid tag format');

// ErrDigestInvalidFormat represents an error while trying to parse a string as a tag.
const ErrDigestInvalidFormat = new Error('invalid digest format');

// ErrNameContainsUppercase is returned for invalid repository names that contain uppercase characters.
const ErrNameContainsUppercase = new Error('repository name must be lowercase');

// ErrNameEmpty is returned for empty, invalid repository names.
const ErrNameEmpty = new Error('repository name must have at least one component');

// ErrNameTooLong is returned when a repository name is longer than NameTotalLengthMax.
const ErrNameTooLong = new Error(`repository name must not be more than ${NameTotalLengthMax} characters`);

// ErrNameNotCanonical is returned when a name is not canonical.
const ErrNameNotCanonical = new Error('repository name must be canonical');

// Reference is an opaque object reference identifier that may include
// modifiers such as a hostname, name, tag, and digest.
interface ReferenceInterface {
  // String returns the full reference
  String: string
}

// FieldType provides a wrapper type for resolving correct reference types when
// working with encoding.
type FieldType = {
  reference: ReferenceInterface,
}

// AsField wraps a reference in a FieldType for encoding.
const AsField = (reference: ReferenceInterface): FieldType => {
  return { reference };
};

// Reference unwraps the reference type from the field to
// return the Reference object. This object should be
// of the appropriate type to further check for different
// reference types.
const Reference = (f: FieldType): ReferenceInterface => {
  return f.reference;
};

// MarshalText serializes the field to byte text which
// is the string of the reference.
const MarshalText = (f: FieldType): [?Buffer, ?Error] => {
  return [Buffer.from(f.reference.toString()), null];
};


// UnmarshalText parses text bytes by invoking the
// reference parser to ensure the appropriately
// typed reference object is wrapped by field.
const UnmarshalText = (f: FieldType): ?Error => {
  const [r, err] = Parse(p.toString());
  if (!isNil(err)) {
    return err;
  }

  f.reference = r;
  return null;
};

// NamedInterface is an object with a full name
interface NamedInterface {
  Reference: Reference,
  Name: string,
}

// TaggedInterface is an object which has a tag
interface TaggedInterface {
  Reference: Reference,
  toString: (t: taggedReference)=> string,
  Tag: string,
}

// NamedTaggedInterface is an object including a name and tag.
interface NamedTaggedInterface {
  Named: NamedInterface,
  Tag: string
}

// DigestedInterface is an object which has a digest
// in which it can be referenced by
interface DigestedInterface {
  Reference: ReferenceInterface,
  Digest: digestDigest
}

// Canonical reference is an object with a fully unique
// name including a name with domain and digest
interface Canonical {
  Named: NamedInterface,
  Digest: Digest
}

// namedRepository is a reference to a repository with a name.
// A namedRepository has both domain and path components.
interface namedRepository {
  Named: NamedInterface,
  Domain: string,
  Path: string
}

// Domain returns the domain part of the NamedInterface reference
const Domain = (named: NamedInterface): string => {
  const [r, ok] = named(namedRepository);
  if (ok) {
    return r.Domain;
  }
  const [domain, _] = splitDomain(named.Name);
  return domain;
};

// Path returns the name without the domain part of the NamedInterface reference
const Path = (named: NamedInterface): { name: string } => {
  const [r, ok] = named(namedRepository);
  if (ok) {
    return r.Path();
  }
  const [_, path] = splitDomain(named.Name);
  return path;
};

const splitDomain = (name: string): [string, string] => {
  const match: ?Array<string> = name.match(CONTAINER_NAME_RE.anchoredNameRegexp);
  if (match && (match.length !== 3)) {
    return ['', name];
  }
  return [match[1], match[2]];
};

// SplitHostname splits a named reference into a
// hostname and name string. If no valid hostname is
// found, the hostname is empty and the full value
// is returned as name
// DEPRECATED: Use Domain or Path
const SplitHostname = (named: NamedInterface): [string, string] => {
  const [r, ok] = named(namedRepository);
  if (ok) {
    return [r.Domain(), r.Path()];
  }
  return splitDomain(named.Name());
};

// Parse parses s and returns a syntactically valid Reference.
// If an error was encountered it is returned, along with a null Reference.
// NOTE: Parse will not handle short digests.
const Parse = (s: string): [?Reference, ?Error] => {
  const matches: ?Array<string> = s.match(CONTAINER_NAME_RE.ReferenceRegexp);
  if (!matches) {
    if (s === '') {
      return [null, ErrNameEmpty];
    }
    if (!isNil(s.match(CONTAINER_NAME_RE.ReferenceRegexp))) {
      return [null, ErrNameContainsUppercase];
    }
    return [null, ErrReferenceInvalidFormat];
  }

  if (matches[1] && (matches[1].length > NameTotalLengthMax)) {
    return [null, ErrNameTooLong];
  }

  let repo: repository;

  const nameMatch: ?Array<string> = matches[1].match(CONTAINER_NAME_RE.anchoredNameRegexp);
  if (nameMatch && (nameMatch.length === 3)) {
    repo.domain = nameMatch[1];
    repo.path = nameMatch[2];
  } else {
    repo.domain = '';
    repo.path = matches[1];
  }

  const ref = reference({
    namedRepository: repo,
    tag: matches[2],
  });
  if (matches[3] !== '') {
    let err: Error;
    const [digest, err] = digest.Parse(matches[3]);
    ref.digest = digest;
    if (!isNil(err)) {
      return [null, err];
    }
  }

  const r = getBestReferenceType(ref);
  if (isNil(r)) {
    return [null, ErrNameEmpty];
  }

  return [r, null];
};

// ParseNamed parses s and returns a syntactically valid reference implementing
// the NamedInterface interface. The reference must have a name and be in the canonical
// form, otherwise an error is returned.
// If an error was encountered it is returned, along with a null Reference.
// NOTE: ParseNamed will not handle short digests.
const ParseNamed = (s: string): [?NamedInterface, ?Error] => {
  const [named, err] = ParseNormalizedNamed(s);
  if (!isNil(err)) {
    return [null, err];
  }
  if (named.String() !== s) {
    return [null, ErrNameNotCanonical];
  }
  return [named, null];
};

// WithName returns a named object representing the given string. If the input
// is invalid ErrReferenceInvalidFormat will be returned.
const WithName = (name: string): [?NamedInterface, ?Error] => {
  if (len(name) > NameTotalLengthMax) {
    return null, ErrNameTooLong;
  }

  const match = name.match(anchoredNameRegexp);
  if (isNil(match) || (match.length !== 3)) {
    return [null, ErrReferenceInvalidFormat];
  }
  return [
    repository({
      domain: match[1],
      path: match[2],
    }), null
  ];
};

// WithTag combines the name from "name" and the tag from "tag" to form a
// reference incorporating both the name and the tag.
const WithTag = (name: NamedInterface, tag: string): [?NamedTaggedInterface, ?Error] => {
  if (!tag.match(anchoredTagRegexp)) {
    return [null, ErrTagInvalidFormat];
  }
  let repo: repository;
  const [r, ok] = name(namedRepository);
  if (ok) {
    repo.domain = r.Domain();
    repo.path = r.Path();
  } else {
    repo.path = name.Name();
  }
  const [canonical, ok] = name(Canonical);
  if (ok) {
    return [
      reference({
        namedRepository: repo,
        tag: tag,
        digest: canonical.Digest(),
      }), null
    ];
  }
  return [
    taggedReference({
      namedRepository: repo,
      tag: tag,
    }), null
  ];
};

// WithDigest combines the name from "name" and the digest from "digest" to form
// a reference incorporating both the name and the digest.
const WithDigest = (name: NamedInterface, digest: digest.Digest): [?Canonical, ?Error] => {
  if (!digest.String().match(anchoredDigestRegexp)) {
    return [null, ErrDigestInvalidFormat];
  }
  let repo: repository;
  const [r, ok] = name(namedRepository);
  if (ok) {
    repo.domain = r.Domain();
    repo.path = r.Path();
  } else {
    repo.path = name.Name();
  }
  const [tagged, ok] = name(TaggedInterface);
  if (ok) {
    return [
      reference({
        namedRepository: repo,
        tag: tagged.Tag(),
        digest: digest,
      }), null
    ];
  }
  return [
    canonicalReference({
      namedRepository: repo,
      digest: digest,
    }), null
  ];
};

// TrimNamed removes any tag or digest from the named reference.
const TrimNamed = (ref: NamedInterface): NamedInterface => {
  const [domain, path] = SplitHostname(ref);
  return repository({
    domain: domain,
    path: path,
  });
};

const getBestReferenceType = (ref: reference): Reference => {
  if (ref.Name() === '') {
    // Allow digest only references
    if (ref.digest !== '') {
      return digestReference(ref.digest);
    }
    return null;
  }
  if (ref.tag === '') {
    if (ref.digest !== '') {
      return canonicalReference({
        namedRepository: ref.namedRepository,
        digest: ref.digest,
      });
    }
    return ref.namedRepository;
  }
  if (ref.digest === '') {
    return taggedReference({
      namedRepository: ref.namedRepository,
      tag: ref.tag,
    });
  }

  return ref;
};

type reference = {
  namedRepository: namedRepository,
  tag: string,
  digest: digestDigest,
}

const String = (r: reference): string => {
  return r.Name() + ':' + r.tag + '@' + r.digest.String();
};

const Tag = (r: reference): string => {
  return r.tag;
};

const Digest = (r: reference): digestDigest => {
  return r.digest;
};

type repository = {
  domain: string,
  path: string
}

const String = (r: repository): string => {
  return r.Name();
};

const Name = (r: repository): string => {
  if (r.domain === '') {
    return r.path;
  }
  return r.domain + '/' + r.path;
};

const Domain = (r: repository): string => {
  return r.domain;
};

const Path = (r: repository): string => {
  return r.path;
};

type digestReference = digestDigest;

const String = (d: digestReference): string => {
  return digest.Digest(d).String();
};

const Digest = (d: digestReference): digestDigest => {
  return digest.Digest(d);
};

type taggedReference = {
  namedRepository: namedRepository,
  tag: string
};

const Tag = (t: taggedReference): string => {
  return t.tag;
};

type canonicalReference = {
  namedRepository: namedRepository,
  digest: digest.Digest
}

const String = (c: canonicalReference): string => {
  return c.Name() + '@' + c.digest.String();
};

const Digest = (c: canonicalReference): digestDigest => {
  return c.digest;
};
