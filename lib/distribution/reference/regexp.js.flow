/* @flow */

// https://github.com/docker/distribution/blob/749f6afb4572201e3c37325d0ffedb6f32be8950/reference/regexp.go

// match compiles the string to a regular expression.
type regexp$MatchType = (s: string) => regexp$RegExp;
type regexp$ResMatchType = (...res: Array<regexp$RegExp>)=>regexp$RegExp;


  // match(s) {return this;}

// literal compiles s into a literal regular expression, escaping any regexp
// reserved characters.
const literal: regexp$MatchType = s => new RegExp(`\\${s}`);

// expression defines a full expression, where each regular expression must
// follow the previous.
const expression: regexp$ResMatchType = (...res) => new RegExp(res.map(r => r.toString()).join(''));

// group wraps the regexp in a non-capturing group.
const group: regexp$ResMatchType = (...res) => new RegExp(`(?:${expression(...res).toString()})`);

// optional wraps the expression in a non-capturing group and makes the
// production optional.
const optional: regexp$ResMatchType = (...res) => new RegExp(`${group(expression(...res)).toString()}?`);

// repeated wraps the regexp in a non-capturing group to get one or more
// matches.
const repeated: regexp$ResMatchType = (...res) => new RegExp(`${group(expression(...res)).toString()}+`);

// capture wraps the expression in a capturing group.
const capture: regexp$ResMatchType = (...res) => new RegExp(`(${expression(...res).toString()})`);

// anchored anchors the regular expression by adding start and end delimiters.
const anchored: regexp$ResMatchType = (...res) => new RegExp(`^${expression(...res).toString()}$`);


// alphaNumericRegexp defines the alpha numeric atom, typically a
// component of names. This only allows lower case characters and digits.
const alphaNumericRegexp: regexp$RegExp = new RegExp('[a-z0-9]+');

// separatorRegexp defines the separators allowed to be embedded in name
// components. This allow one period, one or two underscore and multiple
// dashes.
const separatorRegexp: regexp$RegExp = new RegExp('(?:[._]|__|[-]*)');

// nameComponentRegexp restricts registry path component names to start
// with at least one letter or number, with following parts able to be
// separated by one period, one or two underscore and multiple dashes.
const nameComponentRegexp: regexp$RegExp = expression(
  alphaNumericRegexp,
  optional(repeated(separatorRegexp, alphaNumericRegexp)),
);

// domainComponentRegexp restricts the registry domain component of a
// repository name to start with a component as defined by DomainRegexp
// and followed by an optional port.
const domainComponentRegexp: regexp$RegExp = new RegExp('(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])');

// DomainRegexp defines the structure of potential domain components
// that may be part of image names. This is purposely a subset of what is
// allowed by DNS to ensure backwards compatibility with Docker image
// names.
const DomainRegexp: regexp$RegExp = expression(
  domainComponentRegexp,
  optional(repeated(literal('.'), domainComponentRegexp)),
  optional(literal(':'), match('[0-9]+')),
);

const anchoredDomainRegexp: regexp$RegExp = anchored(DomainRegexp);

// TagRegexp matches valid tag names. From docker/docker:graph/tags.go.
const TagRegexp: regexp$RegExp = match('[\\w][\\w.-]{0,127}');

// anchoredTagRegexp matches valid tag names, anchored at the start and
// end of the matched string.
const anchoredTagRegexp: regexp$RegExp = anchored(TagRegexp);

// DigestRegexp matches valid digests.
const DigestRegexp: regexp$RegExp = match('[A-Za-z][A-Za-z0-9]*(?:[-_+.][A-Za-z][A-Za-z0-9]*)*[:][A-Fa-f0-9]{32,}');

// anchoredDigestRegexp matches valid digests, anchored at the start and
// end of the matched string.
const anchoredDigestRegexp: regexp$RegExp = anchored(DigestRegexp);

// NameRegexp is the format for the name component of references. The
// regexp has capturing groups for the domain and name part omitting
// the separating forward slash from either.
const NameRegexp: regexp$RegExp = expression(
  optional(DomainRegexp, literal('/')),
  nameComponentRegexp,
  optional(repeated(literal('/'), nameComponentRegexp)),
);

// anchoredNameRegexp is used to parse a name value, capturing the
// domain and trailing components.
const anchoredNameRegexp: regexp$RegExp = anchored(
  optional(capture(DomainRegexp), literal('/')),
  capture(nameComponentRegexp,
    optional(repeated(literal('/'), nameComponentRegexp))),
);

// ReferenceRegexp is the full supported format of a reference. The regexp
// is anchored and has capturing groups for name, tag, and digest
// components.
const ReferenceRegexp: regexp$RegExp = anchored(capture(NameRegexp),
  optional(literal(':'), capture(TagRegexp)),
  optional(literal('@'), capture(DigestRegexp)));

// IdentifierRegexp is the format for string identifier used as a
// content addressable identifier using sha256. These identifiers
// are like digests without the algorithm, since sha256 is used.
const IdentifierRegexp: regexp$RegExp = new RegExp('([a-f0-9]{64})');

// ShortIdentifierRegexp is the format used to represent a prefix
// of an identifier. A prefix may be used to match a sha256 identifier
// within a list of trusted identifiers.
const ShortIdentifierRegexp: regexp$RegExp = new RegExp('([a-f0-9]{6,64})');

// anchoredIdentifierRegexp is used to check or match an
// identifier value, anchored at start and end of string.
const anchoredIdentifierRegexp: regexp$RegExp = anchored(IdentifierRegexp);

// anchoredShortIdentifierRegexp is used to check if a value
// is a possible identifier prefix, anchored at start and end
// of string.
const anchoredShortIdentifierRegexp: regexp$RegExp = anchored(ShortIdentifierRegexp);


module.exports = {
  match,
  literal,
  expression,
  optional,
  repeated,
  group,
  capture,
  anchored,
  anchoredDomainRegexp,
  alphaNumericRegexp,
  separatorRegexp,
  nameComponentRegexp,
  domainComponentRegexp,
  DomainRegexp,
  TagRegexp,
  anchoredTagRegexp,
  DigestRegexp,
  anchoredDigestRegexp,
  NameRegexp,
  anchoredNameRegexp,
  ReferenceRegexp,
  IdentifierRegexp,
  ShortIdentifierRegexp,
  anchoredIdentifierRegexp,
  anchoredShortIdentifierRegexp,
};
