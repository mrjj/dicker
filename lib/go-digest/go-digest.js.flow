/* @flow */
// Copyright 2017 Docker, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Digest allows simple protection of hex formatted digest strings, prefixed
// by their algorithm. Strings of type Digest have some guarantee of being in
// the correct format and it provides quick access to the components of a
// digest string.
//
// The following is an example of the contents of Digest types:
//
// 	sha256:7173b809ca12ec5dee4506cd86be934c4596dd234ee82c0662eac04a8c2c71dc
//
// This allows to abstract the digest behind this type and work only in those
// terms.
type Digest = string;
import { type Algorithm } from './algorithm';

// NewDigest returns a Digest from alg and a hash.Hash object.
const NewDigest = (alg: Algorithm, h: hash.Hash): Digest => {
  return NewDigestFromBytes(alg, h.Sum(null));
};

// NewDigestFromBytes returns a new digest from the byte contents of p.
// Typically, this can come from hash.Hash.Sum(...) or xxx.SumXXX(...)
// functions. This is also useful for rebuilding digests from binary
// serializations.
const NewDigestFromBytes = (alg: Algorithm, p: ArrayBuffer): Digest => {
  return NewDigestFromEncoded(alg, alg.Encode(p));
};

// NewDigestFromHex is deprecated. Please use NewDigestFromEncoded.
const NewDigestFromHex = (alg, hex: string): Digest => {
  return NewDigestFromEncoded(Algorithm(alg), hex);
};

// NewDigestFromEncoded returns a Digest from alg and the encoded digest.
const NewDigestFromEncoded = (alg: Algorithm, encoded: string): Digest => {
  return Digest(fmt.Sprintf('%s:%s', alg, encoded));
};

// DigestRegexp matches valid digest types.
const DigestRegexp = new RegExp(`[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+`);

// DigestRegexpAnchored matches valid digest types, anchored to the start and end of the match.
const DigestRegexpAnchored = new RegExp(`^` + DigestRegexp.toString() + `$`);

// ErrDigestInvalidFormat returned when digest format invalid.
const ErrDigestInvalidFormat = new Error('invalid checksum digest format');

// ErrDigestInvalidLength returned when digest has invalid length.
const ErrDigestInvalidLength = new Error('invalid checksum digest length');

// ErrDigestUnsupported returned when the digest algorithm is unsupported.
const ErrDigestUnsupported = new Error('unsupported digest algorithm');

// Parse parses s and returns the validated digest object. An error will
// be returned if the format is invalid.
const Parse = (s: string): [?Digest, ?Error] => {
  const d = Digest(s);
  return [d, d.Validate()];
};

// FromReader consumes the content of rd until io.EOF, returning canonical digest.
const FromReader = (rd: ReadableStream): [?Digest, ?Error] => {
  return Canonical.FromReader(rd);
};

// FromBytes digests the input and returns a Digest.
const FromBytes = (p: Buffer): Digest => {
  return Canonical.FromBytes(p);
};

// FromString digests the input and returns a Digest.
const FromString = (s: string): Digest => {
  return Canonical.FromString(s);
};

class Digest {


// Validate checks that the contents of d is a valid digest, returning an
// error if not.
  Validate(): ?Error {
    const s = this.toString();
    const i = s.indexOf(':');
    if ((i <= 0) || ((i + 1) === s.length)) {
      return ErrDigestInvalidFormat;
    }
    const [algorithm, encoded] = Algorithm(s.slice(i + 1), s.slice(i + 1));
    if (!algorithm.Available()) {
      if (!s.match(DigestRegexpAnchored)) {
        return ErrDigestInvalidFormat;
      }
      return ErrDigestUnsupported;
    }
    return algorithm.Validate(encoded);
  }

// Algorithm returns the algorithm portion of the digest. This will panic if
// the underlying digest is not in a valid format.
  Algorithm(): Algorithm {
    return Algorithm(d.slice(0, this.sepIndex() + 1));
  }

// Verifier returns a writer object that can be used to verify a stream of
// content against the digest. If the digest is invalid, the method will panic.
  Verifier(): Verifier {
    return hashVerifier({
      hash: this.Algorithm().Hash(),
      digest: d,
    });
  }

// Encoded returns the encoded portion of the digest. This will panic if the
// underlying digest is not in a valid format.
  Encoded(): string {
    return this.toString().slice(this.sepIndex() + 1).toString();
  }

// Hex is deprecated. Please use Digest.Encoded.
  Hex(): string {
    return this.Encoded();
  }

  String(): string {
    return this.toString();
  }

  sepIndex(): number {
    const i = this.toString().indexOf(':');

    if (i < 0) {
      throw new Error(`no \':\' separator in digest ${this.toString()}`);
    }

    return i;
  }
}

module.exports = {
  DigestRegexp,
  DigestRegexpAnchored,
  ErrDigestInvalidFormat,
  ErrDigestInvalidLength,
  ErrDigestUnsupported,
};
